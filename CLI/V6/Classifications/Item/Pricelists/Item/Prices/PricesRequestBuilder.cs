// <auto-generated/>
#pragma warning disable CS0618
using ApiSdk.Models;
using ApiSdk.V6.Classifications.Item.Pricelists.Item.Prices.Item;
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using Microsoft.Kiota.Abstractions;
using Microsoft.Kiota.Cli.Commons.Extensions;
using Microsoft.Kiota.Cli.Commons.IO;
using Microsoft.Kiota.Cli.Commons;
using System.Collections.Generic;
using System.CommandLine;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Threading;
using System;
namespace ApiSdk.V6.Classifications.Item.Pricelists.Item.Prices
{
    /// <summary>
    /// Builds and executes requests for operations under \v6\classifications\{classificationId}\pricelists\{pricelistId}\prices
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    public partial class PricesRequestBuilder : BaseCliRequestBuilder
    {
        /// <summary>
        /// Gets an item from the ApiSdk.v6.classifications.item.pricelists.item.prices.item collection
        /// </summary>
        /// <returns>A Tuple&lt;List&lt;Command&gt;, List&lt;Command&gt;&gt;</returns>
        public Tuple<List<Command>, List<Command>> BuildCommand()
        {
            var executables = new List<Command>();
            var builder = new global::ApiSdk.V6.Classifications.Item.Pricelists.Item.Prices.Item.WithPriceItemRequestBuilder(PathParameters);
            executables.Add(builder.BuildGetCommand());
            return new(executables, new(0));
        }
        /// <summary>
        /// Get collection of prices of specified classification and price list
        /// </summary>
        /// <returns>A <see cref="Command"/></returns>
        public Command BuildListCommand()
        {
            var command = new Command("list");
            command.Description = "Get collection of prices of specified classification and price list";
            var classificationIdOption = new Option<string>("--classification-id", description: "Classification identifier") {
            };
            classificationIdOption.IsRequired = true;
            command.AddOption(classificationIdOption);
            var pricelistIdOption = new Option<string>("--pricelist-id", description: "Price list identifier, same as version identifier of the price list product classification version.") {
            };
            pricelistIdOption.IsRequired = true;
            command.AddOption(pricelistIdOption);
            var statusOption = new Option<string[]>("--status", description: "Filter the results by price status. If not specified, results contain only active prices.") {
                Arity = ArgumentArity.ZeroOrMore
            };
            statusOption.IsRequired = false;
            command.AddOption(statusOption);
            var validOnOption = new Option<Date?>("--valid-on", description: "Filter the results by timestamp indicating date value when concept code must be valid. Date in the 'YYYY-MM-DD' format.") {
            };
            validOnOption.IsRequired = false;
            command.AddOption(validOnOption);
            var qvalueOption = new Option<string>("--qvalue", description: "Search criteria value which is used againts fields defined in 'qfields' parameter. Supported wild card is '*' (asterisk)") {
            };
            qvalueOption.IsRequired = false;
            command.AddOption(qvalueOption);
            var qfieldOption = new Option<string[]>("--qfield", description: "Fixed price field name(s) to be used as search criteria targets.") {
                Arity = ArgumentArity.ZeroOrMore
            };
            qfieldOption.IsRequired = false;
            command.AddOption(qfieldOption);
            var modifiedAfterOption = new Option<string>("--modified-after", description: "Filter the results by timestamp indicating date-time value of last modification of concept code.Results contain those concept codes codes which have been changed during and after given date-time. Support formats 'YYYY-MM-DDTHH:MM:SS' and 'YYYY-MM-DD'.") {
            };
            modifiedAfterOption.IsRequired = false;
            command.AddOption(modifiedAfterOption);
            var sortByOption = new Option<string>("--sort-by", description: "A field name by which pricess should be sorted in ascending order. Empty values may be sorted first or last depending on the database engine.") {
            };
            sortByOption.IsRequired = false;
            command.AddOption(sortByOption);
            var pageSizeOption = new Option<int?>("--page-size", description: "Maximum number of results per page") {
            };
            pageSizeOption.IsRequired = false;
            command.AddOption(pageSizeOption);
            var pageOption = new Option<int?>("--page", description: "Refers to the page of the result list.") {
            };
            pageOption.IsRequired = false;
            command.AddOption(pageOption);
            var outputOption = new Option<FormatterType>("--output", () => FormatterType.JSON);
            command.AddOption(outputOption);
            var queryOption = new Option<string>("--query");
            command.AddOption(queryOption);
            command.SetHandler(async (invocationContext) => {
                var classificationId = invocationContext.ParseResult.GetValueForOption(classificationIdOption);
                var pricelistId = invocationContext.ParseResult.GetValueForOption(pricelistIdOption);
                var status = invocationContext.ParseResult.GetValueForOption(statusOption);
                var validOn = invocationContext.ParseResult.GetValueForOption(validOnOption);
                var qvalue = invocationContext.ParseResult.GetValueForOption(qvalueOption);
                var qfield = invocationContext.ParseResult.GetValueForOption(qfieldOption);
                var modifiedAfter = invocationContext.ParseResult.GetValueForOption(modifiedAfterOption);
                var sortBy = invocationContext.ParseResult.GetValueForOption(sortByOption);
                var pageSize = invocationContext.ParseResult.GetValueForOption(pageSizeOption);
                var page = invocationContext.ParseResult.GetValueForOption(pageOption);
                var output = invocationContext.ParseResult.GetValueForOption(outputOption);
                var query = invocationContext.ParseResult.GetValueForOption(queryOption);
                IOutputFilter outputFilter = invocationContext.BindingContext.GetService(typeof(IOutputFilter)) as IOutputFilter ?? throw new ArgumentNullException("outputFilter");
                IOutputFormatterFactory outputFormatterFactory = invocationContext.BindingContext.GetService(typeof(IOutputFormatterFactory)) as IOutputFormatterFactory ?? throw new ArgumentNullException("outputFormatterFactory");
                var cancellationToken = invocationContext.GetCancellationToken();
                var reqAdapter = invocationContext.GetRequestAdapter();
                var requestInfo = ToGetRequestInformation(q => {
                    // q.QueryParameters.Status = status;
                    q.QueryParameters.ValidOn = validOn;
                    if (!string.IsNullOrEmpty(qvalue)) q.QueryParameters.Qvalue = qvalue;
                    // q.QueryParameters.Qfield = qfield;
                    if (!string.IsNullOrEmpty(modifiedAfter)) q.QueryParameters.ModifiedAfter = modifiedAfter;
                    // if (!string.IsNullOrEmpty(sortBy)) q.QueryParameters.SortBy = sortBy;
                    q.QueryParameters.PageSize = pageSize;
                    q.QueryParameters.Page = page;
                });
                if (classificationId is not null) requestInfo.PathParameters.Add("classificationId", classificationId);
                if (pricelistId is not null) requestInfo.PathParameters.Add("pricelistId", pricelistId);
                var errorMapping = new Dictionary<string, ParsableFactory<IParsable>> {
                    {"400", Error.CreateFromDiscriminatorValue},
                    {"401", Error.CreateFromDiscriminatorValue},
                    {"403", Error.CreateFromDiscriminatorValue},
                    {"404", Error.CreateFromDiscriminatorValue},
                    {"500", Error.CreateFromDiscriminatorValue},
                };
                var response = await reqAdapter.SendPrimitiveAsync<Stream>(requestInfo, errorMapping: errorMapping, cancellationToken: cancellationToken) ?? Stream.Null;
                response = (response != Stream.Null) ? await outputFilter.FilterOutputAsync(response, query, cancellationToken) : response;
                var formatter = outputFormatterFactory.GetFormatter(output);
                await formatter.WriteOutputAsync(response, cancellationToken);
            });
            return command;
        }
        /// <summary>
        /// Instantiates a new <see cref="global::ApiSdk.V6.Classifications.Item.Pricelists.Item.Prices.PricesRequestBuilder"/> and sets the default values.
        /// </summary>
        /// <param name="pathParameters">Path parameters for the request</param>
        public PricesRequestBuilder(Dictionary<string, object> pathParameters) : base("{+baseurl}/v6/classifications/{classificationId}/pricelists/{pricelistId}/prices{?modifiedAfter*,page*,pageSize*,qfield*,qvalue*,sortBy*,status*,validOn*}", pathParameters)
        {
        }
        /// <summary>
        /// Instantiates a new <see cref="global::ApiSdk.V6.Classifications.Item.Pricelists.Item.Prices.PricesRequestBuilder"/> and sets the default values.
        /// </summary>
        /// <param name="rawUrl">The raw URL to use for the request builder.</param>
        public PricesRequestBuilder(string rawUrl) : base("{+baseurl}/v6/classifications/{classificationId}/pricelists/{pricelistId}/prices{?modifiedAfter*,page*,pageSize*,qfield*,qvalue*,sortBy*,status*,validOn*}", rawUrl)
        {
        }
        /// <summary>
        /// Get collection of prices of specified classification and price list
        /// </summary>
        /// <returns>A <see cref="RequestInformation"/></returns>
        /// <param name="requestConfiguration">Configuration for the request such as headers, query parameters, and middleware options.</param>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public RequestInformation ToGetRequestInformation(Action<RequestConfiguration<global::ApiSdk.V6.Classifications.Item.Pricelists.Item.Prices.PricesRequestBuilder.PricesRequestBuilderGetQueryParameters>>? requestConfiguration = default)
        {
#nullable restore
#else
        public RequestInformation ToGetRequestInformation(Action<RequestConfiguration<global::ApiSdk.V6.Classifications.Item.Pricelists.Item.Prices.PricesRequestBuilder.PricesRequestBuilderGetQueryParameters>> requestConfiguration = default)
        {
#endif
            var requestInfo = new RequestInformation(Method.GET, UrlTemplate, PathParameters);
            requestInfo.Configure(requestConfiguration);
            requestInfo.Headers.TryAdd("Accept", "application/json");
            return requestInfo;
        }
        /// <summary>
        /// Get collection of prices of specified classification and price list
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class PricesRequestBuilderGetQueryParameters 
        {
            /// <summary>Filter the results by timestamp indicating date-time value of last modification of concept code.Results contain those concept codes codes which have been changed during and after given date-time. Support formats &apos;YYYY-MM-DDTHH:MM:SS&apos; and &apos;YYYY-MM-DD&apos;.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            [QueryParameter("modifiedAfter")]
            public string? ModifiedAfter { get; set; }
#nullable restore
#else
            [QueryParameter("modifiedAfter")]
            public string ModifiedAfter { get; set; }
#endif
            /// <summary>Refers to the page of the result list.</summary>
            [QueryParameter("page")]
            public int? Page { get; set; }
            /// <summary>Maximum number of results per page</summary>
            [QueryParameter("pageSize")]
            public int? PageSize { get; set; }
            /// <summary>Fixed price field name(s) to be used as search criteria targets.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            [QueryParameter("qfield")]
            public global::ApiSdk.Models.PriceQfield[]? Qfield { get; set; }
#nullable restore
#else
            [QueryParameter("qfield")]
            public global::ApiSdk.Models.PriceQfield[] Qfield { get; set; }
#endif
            /// <summary>Search criteria value which is used againts fields defined in &apos;qfields&apos; parameter. Supported wild card is &apos;*&apos; (asterisk)</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            [QueryParameter("qvalue")]
            public string? Qvalue { get; set; }
#nullable restore
#else
            [QueryParameter("qvalue")]
            public string Qvalue { get; set; }
#endif
            /// <summary>A field name by which pricess should be sorted in ascending order. Empty values may be sorted first or last depending on the database engine.</summary>
            [QueryParameter("sortBy")]
            public global::ApiSdk.Models.PriceSortBy? SortBy { get; set; }
            /// <summary>Filter the results by price status. If not specified, results contain only active prices.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            [QueryParameter("status")]
            public global::ApiSdk.Models.PriceStatus[]? Status { get; set; }
#nullable restore
#else
            [QueryParameter("status")]
            public global::ApiSdk.Models.PriceStatus[] Status { get; set; }
#endif
            /// <summary>Filter the results by timestamp indicating date value when concept code must be valid. Date in the &apos;YYYY-MM-DD&apos; format.</summary>
            [QueryParameter("validOn")]
            public Date? ValidOn { get; set; }
        }
    }
}
#pragma warning restore CS0618
